#!/usr/bin/env python3
"""
plot_fixed_budget.py

Plots fixed-budget progress for single-objective or multi-objective runs
from IOH-style .dat files generated by exercise3.py.

- Reads results_ioh/<instance>/<algorithm>/pop_<pop>/run_<run>/data_f0.dat
- Computes mean ± std across runs
- Saves plots as PDF in final/doc/ex3_plots
"""

import os
import glob
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from collections import defaultdict
import numpy as np

# === CONFIG ===
IOH_DIR = "results_ioh"
OUTPUT_DIR = "final/doc/ex3_plots"
os.makedirs(OUTPUT_DIR, exist_ok=True)

sns.set(style="whitegrid", font_scale=1.2)

# === HELPER FUNCTIONS ===
def load_dat_file(path):
    """Load a single .dat file into a pandas DataFrame."""
    try:
        df = pd.read_csv(path, comment="#", delim_whitespace=True, names=["eval", "best"])
        return df
    except Exception as e:
        print(f"⚠️ Failed to read {path}: {e}")
        return None

def collect_instance_data(instance_id, algorithm="single", pop_sizes=None):
    """Collect all runs for one instance, one algorithm."""
    if pop_sizes is None:
        pop_sizes = [10, 20, 50]

    all_runs = defaultdict(list)  # pop_size -> list of DataFrames

    for pop in pop_sizes:
        run_dirs = glob.glob(os.path.join(IOH_DIR, str(instance_id), algorithm, f"pop_{pop}", "run_*"))
        for run_dir in run_dirs:
            dat_path = os.path.join(run_dir, "data_f0.dat")
            df = load_dat_file(dat_path)
            if df is not None:
                all_runs[pop].append(df)

    return all_runs

def compute_mean_std(all_runs):
    """Given a dict pop_size -> list of DataFrames, compute mean ± std at each evaluation step."""
    summary = {}
    for pop, dfs in all_runs.items():
        if not dfs:
            continue
        # align on evaluation steps
        max_eval = max(df["eval"].max() for df in dfs)
        evals = np.arange(1, max_eval + 1)
        # interpolate each run
        run_arrays = []
        for df in dfs:
            run_val = np.interp(evals, df["eval"], df["best"])
            run_arrays.append(run_val)
        run_stack = np.stack(run_arrays)
        mean_vals = run_stack.mean(axis=0)
        std_vals = run_stack.std(axis=0)
        summary[pop] = {"evals": evals, "mean": mean_vals, "std": std_vals}
    return summary

# === PLOTTING FUNCTION ===
def plot_instance_progress(instance_id, algorithm="single", pop_sizes=None):
    all_runs = collect_instance_data(instance_id, algorithm, pop_sizes)
    summary = compute_mean_std(all_runs)

    plt.figure(figsize=(8, 5))

    colors = sns.color_palette("tab10", n_colors=len(summary))
    for i, (pop, stats) in enumerate(sorted(summary.items())):
        plt.plot(stats["evals"], stats["mean"], label=f"Pop {pop}", color=colors[i])
        plt.fill_between(stats["evals"], stats["mean"] - stats["std"], stats["mean"] + stats["std"],
                         color=colors[i], alpha=0.3)

    plt.title(f"Fixed-Budget Progress – Instance {instance_id} ({algorithm})")
    plt.xlabel("Evaluations")
    plt.ylabel("Best-So-Far Fitness")
    plt.legend(title="Population Size")
    plt.tight_layout()

    out_path = os.path.join(OUTPUT_DIR, f"progress_{algorithm}_instance_{instance_id}.pdf")
    plt.savefig(out_path, dpi=300)
    plt.close()
    print(f"Saved {out_path}")

# === MAIN ===
if __name__ == "__main__":
    # Example usage: plot all instances
    instances = [2100, 2101, 2102, 2103, 2200, 2201, 2202, 2203]
    for inst in instances:
        plot_instance_progress(inst, algorithm="single", pop_sizes=[10, 20, 50])
        plot_instance_progress(inst, algorithm="multi", pop_sizes=[10, 20, 50])
